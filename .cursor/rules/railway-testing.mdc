---
description:
globs:
alwaysApply: false
---
# Railway Testing Rules

## Testing Strategy & Workflow

### Branch-Based Testing Approach
```bash
# Create feature branch for testing
git checkout -b feature/your-feature-name

# Make changes and test locally (optional)
docker compose up

# Push to Railway for testing
git add .
git commit -m "feat: your feature description"
git push origin feature/your-feature-name
```

### Railway Auto-Deployment
- Railway detects git push automatically
- Builds and deploys all services
- Provides unique deployment URLs for testing
- Maintains separate environments per branch

## API Testing on Railway

### Health Check Testing
```bash
# Test backend health endpoint
curl https://your-backend-url.railway.app/api/health

# Expected response
{
  "status": "ok",
  "timestamp": "2025-01-XX...",
  "instance_id": "railway-instance-id"
}
```

### Authentication Testing
```bash
# Test with JWT token
curl -H "Authorization: Bearer YOUR_JWT_TOKEN" \
     https://your-backend-url.railway.app/api/billing/subscription

# Test without token (should return 401)
curl https://your-backend-url.railway.app/api/billing/subscription
```

### API Endpoint Testing Checklist
- [ ] **Health**: `/api/health` returns 200
- [ ] **Authentication**: Auth endpoints work correctly
- [ ] **Billing**: `/api/billing/*` endpoints accessible
- [ ] **Agents**: `/api/agent/*` and `/api/agents/*` endpoints
- [ ] **Threads**: `/api/thread/*` endpoints
- [ ] **Projects**: `/api/project/*` endpoints
- [ ] **Sandbox**: `/api/sandboxes/*` endpoints

## Frontend Testing on Railway

### Browser Testing Workflow
1. **Open Railway Frontend URL**
   - Navigate to your Railway frontend deployment
   - Open Browser DevTools (F12)

2. **Network Tab Verification**
   - Monitor API calls in Network tab
   - Verify all calls use `/api/` prefix
   - Check for 404 errors or failed requests

3. **Console Error Monitoring**
   - Watch for JavaScript errors
   - Look for API-related error messages
   - Verify no CORS issues

### User Flow Testing
```javascript
// Test authentication flow
1. Login/Signup process
2. Dashboard loading
3. Project creation
4. Agent initiation
5. Thread management
6. File uploads/downloads
7. Billing information display
```

### Frontend Testing Checklist
- [ ] **Page Loading**: All pages load without errors
- [ ] **API Communication**: Frontend ↔ Backend communication works
- [ ] **Authentication**: Login/logout flows functional
- [ ] **Dashboard**: Data displays correctly
- [ ] **Agent Features**: Agent creation and interaction
- [ ] **File Operations**: Upload/download functionality
- [ ] **Responsive Design**: Mobile and desktop layouts
- [ ] **Dark/Light Mode**: Theme switching works

## Railway CLI Testing Commands

### Deployment Monitoring
```bash
# Watch deployment logs in real-time
railway logs --service backend --follow
railway logs --service frontend --follow

# Check deployment status
railway status
railway ps

# View recent deployments
railway deployments
```

### Service Health Verification
```bash
# Check all services are running
railway ps

# Get service URLs for testing
railway domain

# View environment variables
railway variables --service backend
railway variables --service frontend
```

### Debugging Commands
```bash
# Connect to service shell for debugging
railway shell --service backend

# Check specific deployment logs
railway logs --deployment DEPLOYMENT_ID

# Redeploy if needed
railway redeploy --service backend
```

## Automated Testing Script

### API Testing Script (Node.js)
```javascript
#!/usr/bin/env node
const https = require('https');

const RAILWAY_BACKEND_URL = process.env.RAILWAY_BACKEND_URL;
const TEST_JWT_TOKEN = process.env.TEST_JWT_TOKEN;

const tests = [
  {
    name: 'Health Check',
    path: '/api/health',
    expectedStatus: 200,
    requiresAuth: false
  },
  {
    name: 'Billing Subscription',
    path: '/api/billing/subscription',
    expectedStatus: [200, 401],
    requiresAuth: true
  },
  {
    name: 'Agent Initiation',
    path: '/api/agent/initiate',
    method: 'POST',
    expectedStatus: [200, 401, 422],
    requiresAuth: true
  }
];

// Run automated tests
async function runTests() {
  for (const test of tests) {
    try {
      const result = await testEndpoint(test.path, {
        method: test.method || 'GET',
        headers: test.requiresAuth && TEST_JWT_TOKEN 
          ? { 'Authorization': `Bearer ${TEST_JWT_TOKEN}` }
          : {}
      });
      
      const expectedStatuses = Array.isArray(test.expectedStatus) 
        ? test.expectedStatus 
        : [test.expectedStatus];
        
      if (expectedStatuses.includes(result.status)) {
        console.log(`✅ ${test.name} - PASS (${result.status})`);
      } else {
        console.log(`❌ ${test.name} - FAIL (${result.status})`);
      }
    } catch (error) {
      console.log(`❌ ${test.name} - ERROR: ${error.message}`);
    }
  }
}
```

### Usage
```bash
# Set environment variables
export RAILWAY_BACKEND_URL=https://your-backend.railway.app
export TEST_JWT_TOKEN=your_jwt_token_here

# Run tests
node test-railway-api.js
```

## Integration Testing

### Frontend-Backend Integration
```javascript
// Test API calls from frontend
const testApiIntegration = async () => {
  try {
    // Test getApiUrl helper usage
    const response = await fetch(getApiUrl('/health'));
    console.log('API Integration:', response.status === 200 ? 'PASS' : 'FAIL');
    
    // Test authenticated endpoints
    const authResponse = await fetch(getApiUrl('/billing/subscription'), {
      headers: { 'Authorization': `Bearer ${token}` }
    });
    console.log('Auth Integration:', authResponse.status === 200 ? 'PASS' : 'FAIL');
  } catch (error) {
    console.error('Integration Test Failed:', error);
  }
};
```

### Database Integration Testing
```bash
# Test Supabase connection from Railway
railway shell --service backend

# Inside backend shell
python -c "
from backend.services.supabase import DBConnection
import asyncio

async def test_db():
    db = DBConnection()
    client = await db.client
    result = await client.table('projects').select('*').limit(1).execute()
    print('DB Connection:', 'PASS' if result.data else 'FAIL')

asyncio.run(test_db())
"
```

## Performance Testing

### Load Testing with curl
```bash
# Test API response times
time curl https://your-backend.railway.app/api/health

# Concurrent request testing
for i in {1..10}; do
  curl -s https://your-backend.railway.app/api/health &
done
wait
```

### Frontend Performance Testing
```javascript
// Measure page load times
window.addEventListener('load', () => {
  const loadTime = performance.timing.loadEventEnd - performance.timing.navigationStart;
  console.log('Page Load Time:', loadTime + 'ms');
});

// Test API response times
const testApiPerformance = async () => {
  const start = performance.now();
  await fetch(getApiUrl('/health'));
  const end = performance.now();
  console.log('API Response Time:', (end - start) + 'ms');
};
```

## Error Testing & Debugging

### Common Error Scenarios
```bash
# Test 404 errors (should not occur with proper getApiUrl usage)
curl https://your-backend.railway.app/billing/subscription  # Missing /api

# Test authentication errors
curl https://your-backend.railway.app/api/billing/subscription  # No auth header

# Test malformed requests
curl -X POST https://your-backend.railway.app/api/agent/initiate  # Missing data
```

### Debugging Failed Tests
```bash
# Check service logs for errors
railway logs --service backend | grep ERROR

# Verify environment variables
railway variables --service backend | grep -E "(SUPABASE|API)"

# Test service connectivity
railway shell --service backend
ping redis
ping rabbitmq
```

## Testing Environment Management

### Environment Variable Testing
```bash
# Verify all required variables are set
railway variables --service backend | grep -E "(SUPABASE_URL|ANTHROPIC_API_KEY|OPENAI_API_KEY)"

# Test variable interpolation
railway variables --service backend | grep -E "(REDIS_HOST|RABBITMQ_HOST)"
```

### Service Communication Testing
```bash
# Test internal service communication
railway shell --service backend

# Inside backend shell
curl http://$REDIS_HOST:$REDIS_PORT/ping
curl http://$RABBITMQ_HOST:$RABBITMQ_PORT/api/overview
```

## Regression Testing

### API Regression Tests
```javascript
const regressionTests = [
  // Test previously fixed 404 errors
  { endpoint: '/api/billing/subscription', description: 'Billing API fixed' },
  { endpoint: '/api/agents/123', description: 'Agent API fixed' },
  { endpoint: '/api/agent/initiate', description: 'Agent initiation fixed' },
  { endpoint: '/api/health', description: 'Health check working' }
];

// Run regression test suite
regressionTests.forEach(async (test) => {
  const response = await fetch(getApiUrl(test.endpoint));
  console.log(`${test.description}: ${response.status !== 404 ? 'PASS' : 'FAIL'}`);
});
```

### Frontend Regression Tests
```javascript
// Test for common frontend issues
const frontendRegressionTests = [
  () => document.querySelector('[data-testid="dashboard"]') !== null,
  () => !document.querySelector('.error-404'),
  () => fetch(getApiUrl('/health')).then(r => r.ok),
  () => localStorage.getItem('supabase.auth.token') !== null
];

frontendRegressionTests.forEach((test, index) => {
  try {
    const result = test();
    console.log(`Frontend Test ${index + 1}: ${result ? 'PASS' : 'FAIL'}`);
  } catch (error) {
    console.log(`Frontend Test ${index + 1}: ERROR - ${error.message}`);
  }
});
```

## Production Testing Checklist

### Pre-Production Testing
- [ ] All API endpoints return expected status codes
- [ ] Authentication flows work correctly
- [ ] Database connections established
- [ ] External API integrations functional
- [ ] File upload/download operations work
- [ ] Background tasks processing correctly
- [ ] Error handling working as expected

### Post-Deployment Verification
- [ ] Health checks passing for all services
- [ ] Frontend loads without JavaScript errors
- [ ] API calls use correct URLs with `/api` prefix
- [ ] User authentication and authorization working
- [ ] Billing and subscription features functional
- [ ] Agent creation and interaction working
- [ ] Real-time features (streaming) operational

### Performance Verification
- [ ] API response times under 2 seconds
- [ ] Frontend initial load under 3 seconds
- [ ] Database queries optimized
- [ ] Redis caching effective
- [ ] No memory leaks in long-running processes

## Continuous Testing Strategy

### Automated Testing Pipeline
```yaml
# Example GitHub Actions for Railway testing
name: Railway Testing
on:
  push:
    branches: [feature/*]

jobs:
  test-railway-deployment:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Test API Endpoints
        run: |
          npm install -g @railway/cli
          railway login --token ${{ secrets.RAILWAY_TOKEN }}
          node test-railway-api.js
```

### Manual Testing Schedule
- **Daily**: Health checks and basic functionality
- **Weekly**: Full regression test suite
- **Pre-Release**: Comprehensive integration testing
- **Post-Deployment**: Production verification checklist

## Testing Best Practices

### Test Data Management
- Use test-specific data that doesn't affect production
- Clean up test data after testing sessions
- Use separate test accounts for authentication testing
- Maintain test data consistency across environments

### Test Documentation
- Document all test cases and expected outcomes
- Maintain test result logs for debugging
- Track performance metrics over time
- Record and analyze failure patterns

### Collaboration Testing
- Share test results with team members
- Use Railway's collaboration features for team testing
- Coordinate testing schedules to avoid conflicts
- Maintain shared testing documentation and procedures
